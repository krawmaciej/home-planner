 - linked list as walls representation, connections containing components
 - conversion from 2d to 3d, why can't walls overlap: https://en.wikipedia.org/wiki/Z-fighting and https://en.wikipedia.org/wiki/Z-buffering
 - solution with not overlapping walls lets easily select for which wall does the wall component belong to, and it also solves z-fighting problem.


 - fix: cannot draw a line when starting from other line



Algorithms(solutions to problems) to describe:
 - creating a wall with a hole for window/door
 - 
 - save/caching state
 - updating state from two places (renderer + UI)
 - selecting object from the renderer (update scene)
 - distinction between object that can be selected depending on selected menu
 - keeping object inside wall/on the room scene (???? might be not needed)


See if walls "sticked" together let light go through,
does the ceiling and floor make any light artifacts if they are solid blocks
above and below the walls



Saving system (works same as cache system, implement first - before caching)
    IT MIGHT BE BETTER TO MAKE IT A DIFFERENT OBJECT, IT SERVES A DIFFERENT PURPOSE, SEE DTOs
    HOWEVER PROBLEM WITH THAT IS THAT EACH TIME YOU NEED TO STORE DUPLICATES IN CACHE, WHICH 
    SHOULD ALWAYS BE UP TO DATE.

    object knows id of the load object, and if object model reference is null then lazily initialize
    it to model.clone(), this should work smartly, objects should be loaded only once (lazily)
    and then cloned whenever a new one is needed (object factory or smth).

    objects can be "restored" by storing their matrix4 (rotation + scale) + position.
    example of Furniture array (all clickable objects per "menu" are stored in own arrays)
    btw. JSON
    furniture: [{modelId: 1, matrix: {...}, position: {...}, ...]


Caching system (same mechanism as saving)




componentWillUnmount
Return a callback in useEffect's callback argument and it will be called before unmounting.

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // Return a callback in useEffect and it will be called before unmounting.
    return () => {
      console.log('componentWillUnmount!');
    };
  }, []);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}


getDerivedStateFromProps
Again, taken from the React docs

function ScrollView({row}) {
  let [isScrollingDown, setIsScrollingDown] = useState(false);
  let [prevRow, setPrevRow] = useState(null);

  if (row !== prevRow) {
    // Row changed since last render. Update isScrollingDown.
    setIsScrollingDown(prevRow !== null && row > prevRow);
    setPrevRow(row);
  }

  return `Scrolling down: ${isScrollingDown}`;
}



save all important data in cache

THE CANVAS DOESN'T CREATE MENU COMPONENT, THEY ARE CONNECTED BY STATE (React.useContext)
before using context (if ever, check): https://reactjs.org/docs/context.html
don't use global state but rather pass needed props to rendered components









LATER (never):
 - dissappearing of wall and ceiling when looking from given angle (vector dot product algorithms)
 - optimization of rendering (also hookup listeners from menu to renderer):
https://threejsfundamentals.org/threejs/lessons/threejs-rendering-on-demand.html


done:
 - move drawing to render instead of spamming every mouse movement
 - fix collision so it gets all the intersection points, and splits the drawn wall properly
 - handle: lines starting and ending on the same point
